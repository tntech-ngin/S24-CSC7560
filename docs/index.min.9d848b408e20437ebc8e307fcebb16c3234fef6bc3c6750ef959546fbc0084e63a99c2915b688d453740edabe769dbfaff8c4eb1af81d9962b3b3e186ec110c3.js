var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/F23-CSC4200/docs/prologue/schedule/",title:"Schedule",description:`This is a tentative schedule and will change.
Grading details #Assessment Type Weightage Additional Information In-class Quizzes 20% Exams (3 exams) 35% Programming Assignments 35% One late submission allowed. 50% deducted for other late submissions. Class Participation 10% Class Schedule #Aug 19 -
Introduction, Social Contract, Expectations - Link to Mural Slides Books - Peterson \u0026amp; Davie, Computer Networks - a systems approach. Labs - Every Thursday, in class Week of Aug 20 - Aug 26 #Reading assignment for week 1 - Introduction, Chapter 1.`,content:`This is a tentative schedule and will change.
Grading details #Assessment Type Weightage Additional Information In-class Quizzes 20% Exams (3 exams) 35% Programming Assignments 35% One late submission allowed. 50% deducted for other late submissions. Class Participation 10% Class Schedule #Aug 19 -
Introduction, Social Contract, Expectations - Link to Mural Slides Books - Peterson \u0026amp; Davie, Computer Networks - a systems approach. Labs - Every Thursday, in class Week of Aug 20 - Aug 26 #Reading assignment for week 1 - Introduction, Chapter 1.2 - 1.5 Introduction - Terminologies, Circuit vs Packet Switching, Layers, Architectures vs Protocols Slides Network Performance, Bandwidth/Delay, Jitter Slides Thu, Aug 22 - Lecture Thu, Aug 24 - Lecture and Lab (Setting up Google Cloud VMs) Week of Aug 27 - Sep 02 #Reading assignment - Chapter 2-2.5
Links, Encoding, Frames, Point to point links, Byte Stuffing, Error detection Slides Reliable Delivery, Stop-n-wait, sliding window Slides Examples and Socket Programming Slides Thu, Aug 29 - Lecture Thu, Aug 31 - Lecture and Lab Week of Sep 03 - Sep 09 (Programming Assignment 1 due) #Reading assignment - Chapter 2.6-2.7
Links, Encoding, Frames, Point to point links, Byte Stuffing, Error detection Slides Reliable Delivery, Stop-n-wait, sliding window Slides Examples and Socket Programming Slides Tue, Sep 05 - Lecture Thu, Sep 07 - Lecture and lab Thu, Sep 09 - PA1 due Week of Sep 10 - Sep 16 #Ethernet, Wifi, CSMA-CA/CD, Transmitter algorithm, Collision avoidance, Slides Link Layer Recap Slides Tue, Sep 12 - Lecture Thu, Sep 14 - Lecture and Quiz Thu, Sep 14 - PA1 due Week of Sep 10 - Sep 16 #Reading assignment - Chapter 3-3.2.5, Basic IP
Switching Slides Tue, Sep 12 Thu, Sep 14 Week of Sep 17 - Sep 23 (Programming Assignment 2 due) #Reading assignment Chapter - 3.2.6-3.2.9 Spanning Tree, Loop detection Slides Addressing Slides Tue, Sep 19 - Lecture Thu, Sep 21 - Lecture and Lab Week of Sep 24 - Sep 30 ( Exam 1) #ARP, DHCP Slides NAT, ICMP, Routing vs Switching Slides Tue, Sep 26 - Recap Thu, Sep 28 - Exam 1 Sat, Sep 30 - PA2 due Week of Oct 01 - Oct 07 (Programming Assignment 3 due) #Reading assignment - Chapter 3.3
Routing Slides Routing, Issues with Scaling Slides BGP Slides Tue, Oct 03 - Lecture Thu, Oct 05 - Lab Week of Oct 08 - Oct 14 #Reading assignment - Chapter 4.1
BGP Slides Tue, Oct 10 (Holiday) Thu, Oct 12 - Lab Week of Oct 15 - Oct 21 #Reading assignment - 5.1, 5.2.1-5.2.5
MPLS, End to End communication UDP, TCP Slides [UDP] TCP Flow Control, Three way handshake Slides Tue, Oct 17 - Lecture Thu, Oct 19 - Lecture and Lab Sat, Oct 21 - PA3 due Week of Oct 22 - Oct 28 #Reading assignment - Chapter 6.3
Tue, Oct 24 - Lecture and Recap Week of Oct 29 - Nov 04 ( Exam 2) #Reading assignment - Chapter 9.1
TCP Congestion control, Congestion avoidance Slides Tue, Oct 31 - Lecture and Lab Thu, Nov 02 - Exam 2 Week of Nov 05 - Nov 11 #Reading assignment [DNS]
Reading assignment HTTP
HTTP Slides DNS, Email Slides Tue, Nov 07 - Lecture Thu, Nov 09 - Lecture and Lab Week of Nov 12 - Nov 18 #Reading assignment - Chapter 8.1-8.2
Network Security, Symmetric Key Slides Network Security, Asymmetric Key Slides Tue, Nov 14 - Lecture Thu, Nov 16 - - Lecture and Lab Week of Nov 19 - Nov 25 (Exam 3) #Tue, Nov 21 - Exam 3 Thu, Nov 23 (Holiday - Nov 22-24) Week of Nov 26 - Dec 02 #Demo Mon, Nov 27 - PA4 Due Mon, Nov 27- 10AM - PA4 Poster due Email Cassaundra Trapp at ctrapp@tntech.edu your poster PDF. Tue, Nov 28 - 11-1PM - PA4 Demo - Bruner 208 Template Thu, Nov 30 - Last day of class `}),e.add({id:1,href:"/F23-CSC4200/docs/prologue/lab1/",title:"Lab 1: Setting Up and Testing Virtual Machines on Google Cloud",description:`Note: The following guide provides step-by-step instructions for creating and configuring virtual machines (VMs) on the Google Cloud Platform (GCP). Subsequently, the guide outlines the process of establishing network connectivity between these VMs using the \u0026ldquo;ping\u0026rdquo; command. This exercise aims to provide students with a practical understanding of cloud-based virtualization, network configuration, and basic connectivity testing. This lab is ungraded.
Lab Objectives #Creating two virtual machines on Google Cloud. Configuring network settings for the VMs.`,content:`Note: The following guide provides step-by-step instructions for creating and configuring virtual machines (VMs) on the Google Cloud Platform (GCP). Subsequently, the guide outlines the process of establishing network connectivity between these VMs using the \u0026ldquo;ping\u0026rdquo; command. This exercise aims to provide students with a practical understanding of cloud-based virtualization, network configuration, and basic connectivity testing. This lab is ungraded.
Lab Objectives #Creating two virtual machines on Google Cloud. Configuring network settings for the VMs. Testing network connectivity between the VMs using the \u0026ldquo;ping\u0026rdquo; command. Prerequisites #An active Google Cloud account. Cloud Credit Code. Student Coupon Retrieval Link You will be asked for a name and email address, which needs to match your school domain. A confirmation email will be sent to you with a coupon code. You can request a coupon from the URL and redeem it until: 12/17/2023 Coupon valid through: 8/17/2024 You can only request ONE code per unique email address. Basic familiarity with command-line interfaces and networking concepts. Step 1: Creating Virtual Machines #Log in to your Google Cloud Console. Navigate to the Compute Engine section and click on \u0026ldquo;VM instances.\u0026rdquo; Click the \u0026ldquo;Create Instance\u0026rdquo; button to create your first VM. Choose a suitable name and region for your VM. Select a machine type based on your requirements. Configure boot disk settings. Configure firewall rules to allow ICMP (ping) traffic. Repeat the above steps to create a second VM with a distinct name. Step 2: Configuring Network Settings #Once both VMs are created, take note of their internal and external IP addresses. To enable communication between the VMs, configure their firewall settings to allow ICMP traffic. In the \u0026ldquo;Firewall\u0026rdquo; section, establish a new firewall rule. Provide a name and description for the rule. Set the target tags to match the VMs you\u0026rsquo;ve created. Define the source IP ranges as the internal IP address of the other VM. Allow ICMP protocol. Step 3: Testing Connectivity #Access one of the VMs through SSH using a terminal or command prompt. Utilize the \u0026ldquo;ping\u0026rdquo; command to examine connectivity to the other VM. `}),e.add({id:2,href:"/F23-CSC4200/docs/prologue/lab2/",title:"Lab 2: Use basic networking tools",description:`This lab counts towards your class participation grade
Initial Setup #We will utilize the VMs we created in LAB 1. Open a terminal (can be in your browser or on your laptop) and log into the VMs. Turn in the following (you may use Google and/or collaborate with other students) #Please submit one PDF with your work. You might find the “man” command to be very useful.
SSH into two instances and perform the following tests:`,content:`This lab counts towards your class participation grade
Initial Setup #We will utilize the VMs we created in LAB 1. Open a terminal (can be in your browser or on your laptop) and log into the VMs. Turn in the following (you may use Google and/or collaborate with other students) #Please submit one PDF with your work. You might find the “man” command to be very useful.
SSH into two instances and perform the following tests:
Run ping between two instances and record the outputs for both internal and external interfaces. (5pts) Submit the output as a screenshot and a table that briefly explains each field of the output. (5pts) Install traceroute (sudo apt update \u0026amp;\u0026amp; sudo apt install traceroute). Run traceroute to \u0026ldquo;tntech.edu\u0026rdquo;, record the output (5 pts) Submit the output as a screenshot and briefly explain each field (5 pts) Run ifconfig and record the output. (5pts) Submit the output as a screenshot and the following information for an interface such as “eth0”: IP address, Ethernet Address, netmask, and MTU (5 pts) Run the folloiwing command \u0026ldquo;ip route show\u0026rdquo; and submit the output as a screenshot (5 pts) Explain the first line of the output (5 pts) `}),e.add({id:3,href:"/F23-CSC4200/docs/prologue/lab3/",title:"Lab 3: Introduction to Socket Programming",description:`This lab is ungraded but counts towards your participation grade
Initial Setup #We will utilize the VMs we created in LAB 1. Log into two VMs. Follow along with the instructor. At the end of the lab, you will be able to create a simple client and server. `,content:`This lab is ungraded but counts towards your participation grade
Initial Setup #We will utilize the VMs we created in LAB 1. Log into two VMs. Follow along with the instructor. At the end of the lab, you will be able to create a simple client and server. `}),e.add({id:4,href:"/F23-CSC4200/docs/prologue/5200-additional-assignment/",title:"5200 - Streaming Client Server with ABE",description:"Streaming Client Server with ABE.",content:`Streaming Client-Server with Attribute-Based Encryption (ABE) Assignment #Objective #The primary objective of this assignment is to build a streaming client-server application that employs Attribute-Based Encryption (ABE) for securing key frames. Students are required to implement the client and server, stream media between them, identify key frames to be encrypted, and perform encryption and decryption using ABE. Additionally, the quality of experience (QoE) must be quantified through metrics such as jitter and delay.
Prerequisites #Familiarity with Python or a comparable programming language Basic understanding of client-server architecture Knowledge of video streaming and basic cryptography Experience working with encryption libraries Tasks #Part 1: Setup #Install ABE Libraries: Install the required Attribute-Based Encryption (ABE) libraries on both client and server systems. Install Streaming Software: Install or implement streaming software capable of serving as a client and server. Part 2: Basic Streaming #Stream Video: Stream a video file from the server to the client. You may use any readily available video for this task. Identify Key Frames: Write a program that identifies key frames from the video stream. Part 3: Encryption and Decryption #Encrypt Key Frames: Use the ABE algorithm to encrypt the identified key frames. Stream Encrypted Video: Stream the video with encrypted key frames from the server to the client. Decrypt and Render: Implement logic on the client to decrypt the key frames and render the video stream. Part 4: Quality Metrics #Measure Jitter: Implement a function to measure and log the jitter experienced during the streaming process. Measure Delay: Implement a function to measure and log the delay in the video stream. Quantify QoE: Utilizing the jitter and delay metrics, quantify the Quality of Experience (QoE). Evaluation Criteria #Functional completeness of the client-server streaming system Successful encryption and decryption using ABE Accuracy and completeness in measuring jitter, delay, and QoE Code readability, organization, and documentation Submission Guidelines #Submit your source code files, scripts, and any supplementary documents in a zipped folder. Include a README.md file that explains how to compile and run your programs, along with any necessary setup instructions. Deadline: Nov 19th, 2023 References #ABE Library Documentation: https://acsc.cs.utexas.edu/cpabe/ Video Streaming Protocols and Tools: TBD Quality of Experience (QoE) Metrics: TBD `}),e.add({id:5,href:"/F23-CSC4200/docs/prologue/pa1/",title:"Program 1",description:`This is an INDIVIDUAL Assignment (Do not collaborate) Due - Sept 14, Thursday, 11:59PM
Instructions #Create two separate Python files for the server and client, named server.py and client.py, respectively.
Copy and paste the provided skeleton code into the respective files.
Complete the server code by implementing the missing function calls where indicated by comments. The server should be able to accept connections, receive long messages from clients, process them, and echo back the same message.`,content:`This is an INDIVIDUAL Assignment (Do not collaborate) Due - Sept 14, Thursday, 11:59PM
Instructions #Create two separate Python files for the server and client, named server.py and client.py, respectively.
Copy and paste the provided skeleton code into the respective files.
Complete the server code by implementing the missing function calls where indicated by comments. The server should be able to accept connections, receive long messages from clients, process them, and echo back the same message.
Complete the client code by implementing the missing function calls where indicated by comments. The client should connect to the server, allow the user to input long messages, send them to the server, and display the server\u0026rsquo;s responses.
Test your server and client by running them in separate VMs. Ensure they can communicate and exchange very long messages successfully.
You should perform error handling, add comments for clarity, and optimize the code as needed.
Submit your completed server.py and client.py files for evaluation. Submit through iLearn.
Remember to follow good coding practices and error handling techniques. Ensure that your implementation can handle very long messages without issues.
Server Skeleton Code #import socket # Create a socket object # Define the server address and port # Bind the socket to the server address # Replace the following line with code to bind the socket # Listen for incoming connections (max 5 clients in the queue) # Replace the following line with code to listen for connections print(\u0026quot;Server is listening on\u0026quot;, server_address) while True: # Wait for a client to connect # Replace the following line with code to accept a client connection # Print a message to indicate the client connection # Replace the following line with appropriate logging # Handle client data while True: # Receive data from the client # Replace the following line with code to receive data # ensure you can receive long messages # Process and respond to the client's data # Replace the following line with your data processing logic # Send the response back to the client # Replace the following line with code to send back the same message # Close the client socket # Replace the following line with code to close the client socket Client Skeleton Code #import socket # Create a socket object # Define the server address and port # Connect to the server # Replace the following line with code to connect to the server while True: # Get user input message = input(\u0026quot;Enter a message to send to the server (or 'exit' to quit): \u0026quot;) # Send the message to the server # Replace the following line with code to send the message # Receive and print the server's response # Replace the following line with code to receive and print the response # Make sure you are able to receive long messages # Close the client socket # Replace the following line with code to close the client socket Assignment Rubric #Client Implementation (40 points) #Client Runs (10 points):
The client code runs without errors. Client Runs on Separate VM (10 points):
The client can run on a separate VM and communicate with the server. Exception Handling (10 points):
The client code correctly checks and raises appropriate exceptions for the following socket-related calls: socket.socket() socket.connect() socket.send() socket.recv() Long Message Handling (10 points):
The client can send and receive very long messages (consider testing with messages of at least 1MB in size). Server Implementation (40 points) #Server Runs (10 points):
The server code runs without errors. Server Runs on Separate VM (10 points):
The server can run on a separate VM and communicate with the client. Exception Handling (10 points):
The server code correctly checks and raises appropriate exceptions for the following socket-related calls: socket.socket() socket.bind() socket.listen() socket.accept() socket.send() socket.recv() Long Message Handling (10 points):
The server can receive and process very long messages (consider testing with messages of at least 1MB in size). Best coding practices (20 points) #Error Handling (up to 10 points):
Exit gracefully after client receives the message Server never exits Code Clarity and Comments (up to 10 points):
The code is well-commented and easy to understand, making use of meaningful variable and function names. Total Points: /100
`}),e.add({id:6,href:"/F23-CSC4200/docs/prologue/pa2-f23/",title:"Program 2: Network Packet Handling",description:"Implement a client-server application to handle custom network packets with Python.",content:`This is an INDIVIDUAL Assignment (Do not collaborate) #Due - Sept 30, Saturday, 11:59PM
Instructions #Please read the entire instructions and the skeleton code provided for the server and the client before you start coding.
Setup #Create two separate Python files for the server and client, named server.py and client.py, respectively. Copy and paste the provided skeleton code into the respective files. Implementation #Server: Complete the server code by implementing the unpack_packet function. The server should accept connections, receive custom packets from clients, unpack the packets, and echo back the packet fields. Client: Complete the client code by implementing the create_packet and handle_packet functions. The client should connect to the server, create packets based on user input and command-line arguments, and display the server\u0026rsquo;s echoed responses. Testing and Submission #Test your server and client by running them in separate VMs. Ensure that they can handle different types of payloads based on the header\u0026rsquo;s service type. Error Handling: Perform error handling, add comments for clarity, and optimize the code as needed. Submit your completed server.py and client.py files for evaluation through the submission platform. Server Skeleton Code #import socket import struct def unpack_packet(conn, header_format): # TODO: Implement header unpacking based on received bytes # TODO: Create a string from the header fields # return the string - this will be the payload return packet_header_as_string if __name__ == '__main__': host = 'localhost' port = 12345 # Fixed length header -\u0026gt; Version (1 byte), Header Length (1 byte), Service Type (1 byte), Payload Length (2 bytes) header_format = '' # TODO: Specify the header format using \u0026quot;struct\u0026quot; with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((host, port)) s.listen() conn, addr = s.accept() with conn: print(f\u0026quot;Connected by: {addr}\u0026quot;) while True: try: # TODO: Receive and unpack packet using the unpack_packet function payload_string = unpack_packet(conn, header_format) pass except: print(\u0026quot;Connection closed or an error occurred\u0026quot;) break #TODO: create header #TODO: add payload #TODO: send to client Client Skeleton Code #import argparse import socket import struct def create_packet(version, header_length, service_type, payload): # TODO: Implement packet creation based on parameters # TODO: use the python struct module to create a fixed length header # TODO: Fixed length header -\u0026gt; Version (1 byte), Header Length (1 byte), Service Type (1 byte), Payload Length (2 bytes) # TODO: payload -\u0026gt; variable length # TODO: depending on the service type, handle encoding of the different types of payload. # TODO: service_type 1 = payload is int, service_type 2 = payload is float, service_type 3 = payload is string return packet if __name__ == '__main__': parser = argparse.ArgumentParser(description=\u0026quot;Client for packet creation and sending.\u0026quot;) parser.add_argument('--version', type=int, required=True, help='Packet version') parser.add_argument('--header_length', type=int, required=True, help='Length of the packet header') parser.add_argument('--service_type', type=int, required=True, help='Service type of the payload (1 for int, 2 for float, 3 for string)') parser.add_argument('--payload', type=str, required=True, help='Payload to be packed into the packet') parser.add_argument('--host', type=str, default='localhost', help='Server host') parser.add_argument('--port', type=int, default=12345, help='Server port') args = parser.parse_args() # TODO: Create and send packet using the create_packet function packet = create_packet(args.version, args.header_length, args.service_type, args.payload) #TODO: connect to the server #TODO: send the packet #TODO: recive the packet #TODO: prints header #TODO: prints payload Assignment Rubric #Client Implementation (40 points) #Client Runs (10 points): The client code runs without errors. Client Packs the Packet appropriately (10 points): The client can pack a packet. Type handling: The client code handles different service types properly. The client should be encode different types of payloads (int, float, string) based on the header\u0026rsquo;s service type. Payload Handling (10 points): Prints the header and the new payload returned by the server. The new payload is client header + payload. The header is the header sent by the sever. Server Implementation (40 points) #Server Runs (10 points): The server code runs without errors. Header handling (10 points): The server reads the header first, followed by the payload indicated by the header. Decodes payloads properly: The server code correctly decodes and prints the header and the payload. Constructs and returns new payload =(10 points): The server creates a new payload from the header and payload and sends it back to client. Best coding practices (20 points) #Error Handling (up to 10 points): Exit gracefully after client receives the message, Server never exits. Code Clarity and Comments (up to 10 points): The code is well-commented and easy to understand, making use of meaningful variable and function names. Total Points: /100
`}),e.add({id:7,href:"/F23-CSC4200/docs/prologue/",title:"Prologue",description:"Prologue Doks.",content:""}),e.add({id:8,href:"/F23-CSC4200/docs/prologue/pa3-f23/",title:"Program 3 - Simple Protocol",description:`This is a GROUP Assignment
Due Oct 21, Submit your work on iLearn.
Objectives
Learn to create network packets.
Learn how packets can be sent over the network.
Familiarize you with the concept of sockets.
Learn packing structures, endianness, unpacking, and interpreting network data.
Learn how to use actual data from a packet.
Use packet capture to visually inspect protocols.
Overview
In this warmup project, you are going to implement a client and a server program that will send a command over the network.`,content:`This is a GROUP Assignment
Due Oct 21, Submit your work on iLearn.
Objectives
Learn to create network packets.
Learn how packets can be sent over the network.
Familiarize you with the concept of sockets.
Learn packing structures, endianness, unpacking, and interpreting network data.
Learn how to use actual data from a packet.
Use packet capture to visually inspect protocols.
Overview
In this warmup project, you are going to implement a client and a server program that will send a command over the network. The command simply turns on an LED light. However, the LED light speaks a special protocol. All we know about this protocol is the packet format used for turning on the light. Your task is to create this packet and then send it to the server for turning on this light. Server Specifications
The server takes two arguments:
\$ lightserver -p \u0026lt;PORT\u0026gt; -l \u0026lt;LOG FILE LOCATION\u0026gt; 1.PORT - The port server listens on.
2.Log file location - Where you will keep a record of actions.
For example: \$ lightserver -p 30000 -l /tmp/logfile Deliverables (each worth 5 points)
Server must parse two command line arguments, port and log locations.
The server must not exit after receiving a single packet.
Once a client connects, it logs a message in the following format \u0026quot;Received connection from \u0026lt;CLIENT IP, PORT\u0026gt; \u0026quot;
Once it receives a hello message from the client, it logs the connection and sends a hello back to the client.
You can assume the packet format is the following:
+-----------------+--------------------------+-------------------------+ | | | | | | | | |Version(4 bytes) |Message type (4 bytes) |Message Length (4 bytes) | | | | | | | | | +-----------------+--------------------------+-------------------------+ | | | | | Message (Max 8 Bytes) | | | | | +----------------------------------------------------------------------+ It receives the packet header first, followed by the message. Hint: You need two RECV calls.
Check if Version == 17. If not, log an error message VERSION MISMATCH and continue to listen. Do not exit.
If Version == 17, check the message type. If message Type is 1 - the corresponding command is LIGHTON. If message type is 2 - the corresponding command is LIGHTOFF. No other command is supported.
If the server sees a supported command, log \u0026ldquo;EXECUTING SUPPORTED COMMAND: COMMANDNAME\u0026rdquo;, else log \u0026lt;\u0026ldquo;IGNORING UNKNOWN COMMAND: COMMANDNAME\u0026rdquo;.
Send back a \u0026ldquo;SUCCESS\u0026rdquo; message to the client.
It turns on or turns off the LED on your circuit based on the command sent by the client.
Make sure server does not exit on 0 byte messages. Client Specifications
\$ lightclient -s \u0026lt;SERVER-IP\u0026gt; -p \u0026lt;PORT\u0026gt; -l LOGFILE The client takes three arguments:
Server IP - The IP address of the server. PORT - The port the server listens on. Log file location - Where you will keep a record of packets you received. For example: \$ lightclient -s 192.168.2.1 -p 6543 -l LOGFILE Client Requirements (each worth 5 points, item 7 is worth 10 points)
The client must parse three command line arguments, server, port, and logfile. The client should connect to the server on the specified port. Constructs and sends a hello packet to the server. +-----------------+--------------------------+-------------------------+ | | | | | | | | |Version(4 bytes) |Message type (4 bytes) |Message Length (4 bytes) | | | | | | | | | +-----------------+--------------------------+-------------------------+ | | | | | Message (HELLO) | | | | | +----------------------------------------------------------------------+ Receive reply from Server - if version is 17, log \u0026ldquo;VERSION ACCEPTED\u0026rdquo;, else log - \u0026ldquo;VERSION MISMATCH\u0026rdquo; If version is accepted, send a command packet. +-----------------+--------------------------+-------------------------+ | | | | | | | | |Version(4 bytes) |Message type (4 bytes) |Message Length (4 bytes) | | | | | | | | | +-----------------+--------------------------+-------------------------+ | | | | | COMMAND (LIGHTON/LIGHTOFF) | | | | | +----------------------------------------------------------------------+ Receive the server\u0026rsquo;s reply, log the reply, and gracefully shutdown the socket. You can assume the server always replies with a \u0026ldquo;SUCCESS\u0026rdquo; message for this assignment. Use TCPDUMP or Wireshark to capture the interactions, turn the .pcap file in with the assignment. Additional requirements:
Code must compile/run on your VM. You will demo this to the TA.
You must pack the packet in a structure. If you are using python, use the struct module.
Pay extra attention to byte-order encoding before sending the packet. Big-endianness is the dominant ordering in today\u0026rsquo;s network protocols.
Sample Output #Server side
Received connection from (IP, PORT): ('127.0.0.1', 53888) Received Data: version: 17 message_type: 1 length: 1280 VERSION ACCEPTED Received Data: version: 17 message_type: 2 length: 1792 VERSION ACCEPTED EXECUTING SUPPORTED COMMAND: LIGHTON Returning SUCCESS Received connection from (IP, PORT): ('127.0.0.1', 53890) Received Data: version: 17 message_type: 1 length: 1280 VERSION ACCEPTED Received Data: version: 17 message_type: 2 length: 1792 VERSION ACCEPTED EXECUTING SUPPORTED COMMAND: LIGHTON Returning SUCCESS Client Side
Run 1
Received Data: version: 17 type: 1 length: 1280 VERSION ACCEPTED Received Message Hello Sending command Received Data: version: 17 type: 2 length: 1792 VERSION ACCEPTED Received Message SUCCESS Command Successful Closing socket Run 2
Sending HELLO Packet Received Data: version: 17 type: 1 length: 1280 VERSION ACCEPTED Received Message Hello Sending command Received Data: version: 17 type: 2 length: 1792 VERSION ACCEPTED Received Message SUCCESS Command Successful Closing socket `}),e.add({id:9,href:"/F23-CSC4200/docs/",title:"Docs",description:"Docs Doks.",content:""}),e.add({id:10,href:"/F23-CSC4200/docs/prologue/pa4/",title:"Program 4 - Detect a Person",description:`Due Date - Nov 20, 2023 #Objectives
The objective of this assignment is to design and implement a client-server system using Raspberry Pi devices. The server will control an LED, while the client will sense motion using a Passive Infrared Sensor (PIR) and communicate with the server to blink the LED. The assignment includes establishing a three-way handshake, sending blink duration and count information, acknowledging the data, and responding to motion detection by blinking the LED.`,content:`Due Date - Nov 20, 2023 #Objectives
The objective of this assignment is to design and implement a client-server system using Raspberry Pi devices. The server will control an LED, while the client will sense motion using a Passive Infrared Sensor (PIR) and communicate with the server to blink the LED. The assignment includes establishing a three-way handshake, sending blink duration and count information, acknowledging the data, and responding to motion detection by blinking the LED. The client and server communications MUST use UDP (SOCK_DGRAM) and NOT TCP.
The objectives are:
\u0026ndash; Learn about physical computing
\u0026ndash; Learn about protocol development
Server Specifications
The server (we name it lightserver) takes two arguments:
\$ lightserver -p \u0026lt;PORT\u0026gt; -s \u0026lt;LOG FILE LOCATION\u0026gt; 1.PORT - The port server listens on.
2.Log File Location - log file location
Server\u0026rsquo;s Functional requirements
The server must open a UDP socket on the specified port number The server should gracefully process incorrect port number and exit with a non-zero error code The server runs indefinitely - it does not exit. The server accepts connections from multiple clients (bonus points) server works with any client developed by other teams (bonus points) Client Specifications
The client (we name it lightclient) takes three arguments: \$ lightclient -s \u0026lt;SERVER-IP\u0026gt; -p \u0026lt;PORT\u0026gt; -l LOGFILE The client takes three arguments:
1.Server IP - The IP address of the lightserver.
2.PORT - The port the server listens on.
2.Log file location - Where you will keep a record of packets you received.
For example: \$ lightclient -s 192.168.2.1 -p 6543 -l LOGFILE Packet Specification
The payload of each UDP packet sent by server and client MUST start with the following 12-byte header. All fields are in network order (most significant bit first):
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Acknowledgment Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Not Used |A|S|F| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Where:
Sequence Number (32 bits): If SYN is present (the S flag is set) the sequence number is the initial sequence number (randomly choosen).
Acknowledgement Number (32 bits): If the ACK bit is set, this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established this is always sent.
The acknowledgement number is given in the unit of bytes (how many bytes you have sent)
Not Used (29 bits): Must be zero.
A (ACK, 1 bit): Indicates that there the value of Acknowledgment Number field is valid
S (SYN, 1 bit): Synchronize sequence numbers
F (FIN, 1 bit): Finish, No more data from sender
This is the protocol you will implement
The client opens a UDP socket and initiate 3-way handshake to the specified hostname/ip and port. Essentially, the client and server will exchange three packets with the following flags set: (1) SYN (2) SYN|ACK (3)ACK. At the end of the handshake, they will have learned each other\u0026rsquo;s sequence number.
The client then sends the duration and number of blinks as a payload.
The server acknowledges the duration and the number of blinks.
The client senses motion using the PIR.
When motion is detected, the client logs it, and sends a message with the following string as the payload :MotionDetected
The server parses it, logs :MotionDetected to its log, and drives the LED for the pre-determined amount of times.
Client sends a packet with the FIN bit set. The server logs \u0026ldquo;:Interaction with completed. This finishes the interaction.
Timestamp format is \u0026ldquo;YYYY-MM-DD-HH-MM-SS\u0026rdquo;.
Hardware Components #Raspberry Pi Passive Infrared Sensor (PIR) LED Resistor Jumper wires Breadboard Server Setup #The server Raspberry Pi should be programmed to drive the LED. It should be capable of receiving data from the client and blinking the LED accordingly. Client Setup #The client Raspberry Pi should be programmed to interface with the PIR sensor. It should be able to establish a connection with the server. The client should continuously sense motion using the PIR sensor. You may test both server and client on the same board.
Submission:
Submit your code, packet capture in PCAP format, and your logs as a ZIP file. Additional requirements:
Code must compile/run on the PIs.
For each packet received, log both at server and receiver in the following format:
\u0026quot;RECV\u0026quot; \u0026lt;Sequence Number\u0026gt; \u0026lt;Acknowledgement Number\u0026gt; [\u0026quot;ACK\u0026quot;] [\u0026quot;SYN\u0026quot;] [\u0026quot;FIN\u0026quot;] \u0026quot;SEND\u0026quot; \u0026lt;Sequence Number\u0026gt; \u0026lt;Acknowledgement Number\u0026gt; [\u0026quot;ACK\u0026quot;] [\u0026quot;SYN\u0026quot;] [\u0026quot;FIN\u0026quot;] Hints #def create_packet(**kwargs):
data = struct.pack('!I', s_n) #pack the version .... data += struct.pack(\u0026quot;!c\u0026quot;, ack) #pack the ACK data += struct.pack(\u0026quot;!c\u0026quot;, syn) #pack the SYN data += struct.pack(\u0026quot;!c\u0026quot;, fin) #pack the FIN .... return data send_data = create_packet(sequence_number=100, ack_number=0, ack = 'Y', syn = 'N', fin = 'N', payload=data) Rubric #Protocol design points 1-7 - 10 points each. Successful reading from PIR - 10 points. Successful LED blinking - 10 points. Server can handle multiple clients - 10 points (bonus) Works with other teams\u0026rsquo; implementation - 10 points (bonus) Do not collaborate on code but test with each other\u0026rsquo;s code If your code works with another team\u0026rsquo;s code, you both get 10 points `}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()